-- DEMO

-- Example taken from Frenetic (POPL'14)
-- Sample topology (from Fig 8):
--       _______       _______
--  hâ‚ --1      |     |      2-- hâ‚‚
--      |   A  5-------6  B   |
--  hâ‚ƒ --3      |     |      4-- hâ‚„
--       -------       -------

-- Two switches (A and B)
-- Switch A has 3 ports, numbered 1, 3 and 5
-- Switch B has 3 ports, numbered 2, 4 and 6
-- Hosts are connected at A.1, A.3, B.2 and B.4
-- and A.5 and B.6 are connected together

-- v Naming switches
A = 0
B = 1

-- v Defining the topology
topo = (@sw=A?â‹…@pt=5?â‹…@swâ†Bâ‹…@ptâ†6) âˆª
       (@sw=B?â‹…@pt=6?â‹…@swâ†Aâ‹…@ptâ†5) âˆª
       (@sw=A?â‹…@pt=1?) âˆª
       (@sw=A?â‹…@pt=3?) âˆª
       (@sw=B?â‹…@pt=2?) âˆª
       (@sw=B?â‹…@pt=4?)

-- v Naming Hosts
hâ‚ = (@sw=A?â‹…@pt=1?)
hâ‚‚ = (@sw=B?â‹…@pt=2?)
hâ‚ƒ = (@sw=A?â‹…@pt=3?)
hâ‚„ = (@sw=B?â‹…@pt=4?)


-- ROUTING POLICY

-- We can define a policy routing packets
-- between host 1 (A.1) and host 2 (B.2)
--       _______       _______
--  hâ‚ --1--,   |     |   ,--2-- hâ‚‚
--      |   '--5-------6--'   |
--  hâ‚ƒ --3      |     |      4-- hâ‚„
--       -------       -------

-- v Connect A.1 with A.5
paâ‚ = @sw=A?â‹…(@pt=5?â‹…@ptâ†1 âˆª @pt=1?â‹…@ptâ†5)
-- v Connect B.2 with B.6
pbâ‚ = @sw=B?â‹…(@pt=6?â‹…@ptâ†2 âˆª @pt=2?â‹…@ptâ†6)

pâ‚ = paâ‚ âˆª pbâ‚


-- REACHABILITY

-- This is usually of the form (from ğ‘ to ğ‘)
-- ğ‘ â‹… (ğ‘ â‹… ğ‘¡ â‹… Î´)* â‹… ğ‘ â‰¢ âˆ…
-- v some packets from hâ‚ reach hâ‚‚
check hâ‚â‹…(pâ‚â‹…topoâ‹…Î´)â‹†â‹…hâ‚‚ â‰¢ âˆ…
-- v no packet from hâ‚ reaches hâ‚„
check hâ‚â‹…(pâ‚â‹…topoâ‹…Î´)â‹†â‹…hâ‚„ â‰¡ âˆ…


-- SLICING

-- New policy wants to route traffic
-- between host 3 (A.3) and host 4 (B.4)
--       _______       _______
--  hâ‚ --1      |     |      2-- hâ‚‚
--      |   ,--5-------6--,   |
--  hâ‚ƒ --3--'   |     |   '--4-- hâ‚„
--       -------       -------

-- v Connect A.3 and A.5 
paâ‚‚ = @sw=A?â‹…(@pt=5?â‹…@ptâ†3 âˆª @pt=3?â‹…@ptâ†5)
-- v Connect B.4 and B.6
pbâ‚‚ = @sw=B?â‹…(@pt=6?â‹…@ptâ†4 âˆª @pt=4?â‹…@ptâ†6)

pâ‚‚ = paâ‚‚ âˆª pbâ‚‚

-- If we wanted to run both pâ‚ and pâ‚‚
-- at the same time on our network
-- we could take the union of both policy...
-- But this would have too many behaviors
check ((pâ‚âˆªpâ‚‚)â‹…topoâ‹…Î´)â‹† â‰¢ (pâ‚â‹…topoâ‹…Î´)â‹†âˆª(pâ‚‚â‹…topoâ‹…Î´)â‹†

-- For example,
-- v Some packets from hâ‚ reach hâ‚„
check hâ‚â‹…((pâ‚âˆªpâ‚‚)â‹…topoâ‹…Î´)â‹†â‹…hâ‚„ â‰¢ âˆ…

-- We can define a slicing function
-- which tags the packets belonging
-- to the slice with a unique id
slice = Î» p â‡’ Î» inpred â‡’ Î» outpred â‡’ Î» w â‡’
  let pre = @tag=0?â‹…inpred?â‹…@tagâ†w âˆª @tag=w?
  let post = outpred? â‹… @tagâ†0 âˆª Â¬outpred?
  preâ‹…pâ‹…post

-- v the first slice connects hâ‚ and hâ‚‚
inâ‚ = @sw=Aâˆ§@pt=1 âˆ¨ @sw=Bâˆ§@pt=2
outâ‚ = @sw=Aâˆ§@pt=1 âˆ¨ @sw=Bâˆ§@pt=2
sâ‚ = slice pâ‚ inâ‚ outâ‚ 1

-- v the second slice connects hâ‚ƒ and hâ‚„
inâ‚‚ = @sw=Aâˆ§@pt=3 âˆ¨ @sw=Bâˆ§@pt=4
outâ‚‚ = @sw=Aâˆ§@pt=3 âˆ¨ @sw=Bâˆ§@pt=4
sâ‚‚ = slice pâ‚‚ inâ‚‚ outâ‚‚ 2

-- We can check that the resulting policy is what we want...
-- v hâ‚ is connected to hâ‚‚
check hâ‚â‹…((sâ‚âˆªsâ‚‚)â‹…topoâ‹…Î´)â‹†â‹…hâ‚‚ â‰¢ âˆ…
-- v hâ‚ƒ is connected to hâ‚„
check hâ‚ƒâ‹…((sâ‚âˆªsâ‚‚)â‹…topoâ‹…Î´)â‹†â‹…hâ‚„ â‰¢ âˆ…
-- v hâ‚ is not connected to hâ‚„
check hâ‚â‹…((sâ‚âˆªsâ‚‚)â‹…topoâ‹…Î´)â‹†â‹…hâ‚„ â‰¡ âˆ…
-- v hâ‚ƒ is not connected to hâ‚‚
check hâ‚ƒâ‹…((sâ‚âˆªsâ‚‚)â‹…topoâ‹…Î´)â‹†â‹…hâ‚‚ â‰¡ âˆ…

-- v we can show that sâ‚ and sâ‚‚ do not affect each others
check ((sâ‚âˆªsâ‚‚)â‹…topoâ‹…Î´)â‹† â‰¡ (sâ‚â‹…topoâ‹…Î´)â‹†âˆª(sâ‚‚â‹…topoâ‹…Î´)â‹†

-- However, the following is not the same
-- since routing in sâ‚ and sâ‚‚ tags packets
check ((sâ‚âˆªsâ‚‚)â‹…topoâ‹…Î´)â‹† â‰¢ (pâ‚â‹…topoâ‹…Î´)â‹†âˆª(pâ‚‚â‹…topoâ‹…Î´)â‹†

